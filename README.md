# web_oAuth2.0
basic study about web oAuth 2.0 (ft.Udemy [생활코딩] WEB - OAuth 2.0)

## OT
oAuth과 관련해서 3가지의 참여자가 존재합니다.

![image](https://github.com/SAMEZ-0129/web_oAuth2.0/assets/81644075/dd12e7f7-56da-4f11-aacd-f62cb1a18809)
서비스를 제공하는 나 / 내 서비스를 사용하는 사용자(user) / 사용자가 활용하는 타 서비스(외부 서비스)

ex. 내가 운영하는 서비스에서 사용자의 페이스북/구글/네이버 계정 아이디와 비밀번호를 전달받아(저장해서) 내 서비스에 로그인 할 수 있게 해줌

이와 같은 방법은 매우 간단하면서도 타 서비스의 기능을 모두 활용 가능하다는 점에서 매우 유용합니다.

하지만, 내 아이디와 비밀번호를 처음보는 서비스에 그냥 제공하는 것은 매우 찝찝한 일이고, 보안에 안좋은 영향을 준다 (신뢰가 없기에). 또한, 구글/페이스북/네이버 같은 타 서비스도 자신들의 사용자의 게정 정보를 신뢰할 수 없는 서비스에 제공한다는 것은 불만족스러운 일이 아닐 수 없다. 

이러한 상황을 위해 존재하는 것이 oAuth인 것이다. 그렇다면, oAuth를 활용하면 무엇이 다른가?

기존에는 사용자의 아이디/비밀번호를 내 서비스가 보관하고 있었다면, 이제는 구글같은 서비스에서 사용자의 요청에 의해 accessToken이라는 일종의 비밀번호를 대신하는 인증서를 발급합니다. 

accessToken의 장점으로는
- 본인들의 서비스의 실제 아이디/비밀번호가 아님
- 본인들의 서비스의 모든 기능을 제공하지 않고, 필요한 기능만 제공할 수 있다
- 전달받은 accessToken을 통해서 구글같은 서비스에 접근해서 데이터를 가져오거나 수정, 생성, 삭제 등이 가능하다

## 본문
### oAuth에 등장하는 3개의 주체

우리가 만든 서비스 = 내것,
우리의 서비스를 사용하는 사람 = 유저,
유저가 사용하는 타 서비스 = 그들

 그들(타 서비스)를 우리가 원하는 자원을 갖는 서버라는 의미에서 **'리소스 서버'** 라고 부름

리소스 서버에 가입이 되어있는 유저 = **리소스 소유자**

우리의 서비스 =  **클라이언트**

추가로 리소스 서버는 우리가 원하는 데이터를 가진 서버를 의미하고 authorization server라는 인증서버는 인증과 관련된 처리를 위해 존재하는 서버임(oAuth 공식 메뉴얼)

이번 강의에서는 두 서버를 구분하지 않고 편의상 합쳐서 리소스 서버라고 부르자

### oAuth를 등록하는 절차 - 등록
클라이언트가 리소스 서버를 이용하기 위해서는 리소스 서버로부터 승인을 사전에 받아야 한다 = 등록

서비스마다 등록하는 방법의 차이는 있지만, 공통적인 부분은 ClientID와 ClientSecret 그리고 Authorized Redirect URLs를 전달 받는 것은 동일하다

ClientID: 우리가 만든 애플리케이션의 식별자/ID

ClientSecret: 해당 ID의 비밀번호 (ClientID는 외부에 노출되어도 이슈가 아니지만, ClientSecret은 절대 노출되선 안된다)

Authorized Redirect URLs: 리소스 서버가 권한을 부여하는 과정에서 Authorize Code라는 값을 전달해 주는데, 해당 값을 전달받을 주소(리소스 서버는 해당 URL이 아닌 다른 곳에서의 요청은 무시)

### 인증 받는 방법
등록하는 절차를 통해 리소스 서버와 클라이언트는 ClientID와 ClientSecret을 서로 공통적으로 인지하고 있는 상황

![image](https://github.com/SAMEZ-0129/web_oAuth2.0/assets/81644075/26244e7e-4d0f-4926-b80c-c5529a21c637)

리소스 서버에 특정 기능만 사용이 필요한 상황이면 모든 기능에 대한 인증을 받는 것이 아닌, 필요한 인증만 받는게 클라이언트와 리소스 서버 서로 이득

유저가 클라이언트로 로그인을 한다고 가정하면, 해당 기능을 위해 서비스(구글,페이스북 등)의 로그인 버튼을 만들고 사진과 같이 리소스 서버로 인증을 요청하는 방식을 사용한다

유저가 로그인을 진행 > 요청하는 서비스에 유저가 로그인되어있지 않을 경우, 로그인화면 노출 / 로그인된 상태라면 ClientID값을 확인하고 해당 값과 동일한 값이 서버에 있는지 확인 > 서버가 가지고 있는 해당 클라이언트의 정보 중 redirect URL과 실제 요청이 이루어지고 있는 redirect URL을 비교한다 > 같을 경우 클라이언트가 요청하는 권한을 부여할 것인지 유저한테 물어본다(아래 이미지 참고)

![image](https://github.com/SAMEZ-0129/web_oAuth2.0/assets/81644075/62e6c3f5-9812-4a0a-8bc7-2927c80e9bd1)

권한을 부여하는것에 클라이언트가 동의할 경우, 리소스 서버는 해당 작업을 기록해서 저장한다 (유저의 아이디가 1이라고 가정)

![image](https://github.com/SAMEZ-0129/web_oAuth2.0/assets/81644075/028c9c01-e7de-4ccc-ab79-a4e2cb1b70ae)

